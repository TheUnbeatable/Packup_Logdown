# 后缀数组
## Algorithm
倍增,基数排序,注意按第二关键字排序后第一关键字要从后往前排.
注意两个关键字相同的时候要使他们rank相同.
height数组是重点.
```cpp CalHeight
  for (int i = 1, j, k = 0; i <= n; hei[rnk[i ++]] = k)
    for (k ? k -- : 0, j = ord[rnk[i] - 1]; c[i + k] == c[j + k]; k ++);
```

---
# 后缀自动机
## Algorithm
### 动机
子串s在`$ [l_1,r_1),[l_2,r_2)...[l_n,r_n) $`处出现,那么它可以匹配的后缀集合`$ right(s)= \{ r_1,r_2...r_n \} $`
我们发现有一些子串的right是相同的,他们的长度在`$ [Min_s,Max_s] $`内.
### 定义
节点s代表一个right集合.
trans(s,c)代表加入字符c后转移到的状态.
fa[s]代表一个right集合完全包含right(s)的状态.
ST(s)表示从root接受s后的状态.
### 增量法建造 : 
当前T，长度L，加入x,上一次状态为p
令p=ST(T) ，则Right(p)={L}
新建np=ST(Tx),Max[np]=Max[p].
p的fa祖先的Right里都有L,现在要插入L+1
对于没有--x-->的祖先v，trans(v,x)=np
IF 一直到root之后也没有这样的祖先，Parent(np)=root
ELSE p=第一个有的祖先,令q=trans(p,x)  //注意这里的Right(q)={ri+1|s[ri]==c}不包括rn
　　IF Max(q)==Max(p)+1,说明强行加入L+1不会使Max(q)变小，直接fa(np)=q
　　ELSE 新建nq复制q，trans完全相同用nq代替trans(v,x)=q的q， fa(nq)=fa(q),fa(q)=fa(np)=nq

### 性质:
fa的关系构成了一棵树,父亲的right集合是儿子的right集合的并,儿子的right集合之间没有交集.
查找某一个子串[l,r]出现次数:找到[1,r]的状态,只要Max(fa[x]) >= r-1不断向上跳.

```cpp SAM
inline void extend(int x) {
  int p = lst, np = lst = ++ tot;
  Max[np] = Max[p] + 1;
  for (; !trans[p][x] && p; p = fa[p]) trans[p][x] = np;
  if (!p) fa[np] = 1;
  else {
    int q = trans[p][x];
    if (Max[p] + 1 == Max[q]) fa[np] = q;
    else {
      int nq = ++ tot;
      memcpy(trans[nq], trans[q], sizeof trans[q]);
      Max[nq] = Max[p] + 1;
      fa[nq] = fa[q];
      fa[np] = fa[q] = nq;
      for (; trans[p][x] == q; p = fa[p]) trans[p][x] = nq;
    }
  }
}
```

# Problems
## BZOJ 3676 [Apio2014]回文串
### Description
回文串的权值定义为长度*出现次数.求一个字符串中最大的权值.(len <= 1e5)
### Idea
利用manacher求出所有的回文串,然后在后缀自动机上查询出现次数.
由于查询有n次,所以要用倍增加速.

### BZOJ 3145 [Feyat Cup 1.5]Str
### Description
求两个字符串的最长公共子串,允许有一位(len <= 1e5)不相同.
### Idea
利用后缀自动机我们可以实现完全相同的最长公共子串.
利用后缀数组我么可以实现后缀的匹配.
由rank的性质,rank越相近,lcp越长.
那么在后缀自动机的一个状态上维护一个set记录所有的`$ height[r+2](r \in right(s)) $`
要把两个串分开来存,放在A和B两个set中.
一个父亲的set是所有儿子set的并,这个可以用启发式合并.
合并(A1,B1)和(A2,B2).
遍历A1,B2中较小的一个在另一个里面查找最接近的height,统计答案.
遍历A2,B1中较小的一个在另一个里面查找最接近的height,统计答案.
遍历A1,B2中较小的一个,插入到另一个里面.
遍历A2,B1中较小的一个,插入到另一个里面.
复杂度O(Nlog^2N).

# Codes
```cpp Suffix Array
int rnk[N], id[N], buc1[N], buc2[N], _rnk[N], ord[N], hei[N];
inline void GetRank(int n) {
  int g = max(n, 130);
  for (int i = 1; i <= n; i ++) rnk[i] = c[i];
  for (int h = 1; h <= n; h <<= 1) {
    memset(buc1, 0, sizeof(int) * (g + 2));
    memset(buc2, 0, sizeof(int) * (g + 2));
    int t = h >> 1;
    for (int i = 1; i <= n; i ++) {
      buc1[rnk[min(N - 1, i + t)]] ++;
      buc2[rnk[i]] ++;
    }
    for (int i = 1; i <= max(n, 130); i ++) {
      buc1[i] += buc1[i - 1];
      buc2[i] += buc2[i - 1];
    }
    for (int i = 1; i <= n; i ++) id[buc1[rnk[min(N - 1, i + t)]] --] = i;
    int pre = n;
    for (int i = n; i >= 1; i --) {
      if (i != n && rnk[min(N - 1, id[i] + t)] != rnk[min(N - 1, id[i + 1] + t)]) {
        for (int j = i + 1; j <= pre; j ++) buc2[rnk[id[j]]] --;
        pre = i;
      }
      _rnk[id[i]] = buc2[rnk[id[i]]];
    }
    swap(rnk, _rnk);
  }
  for (int i = 1; i <= n; i ++) ord[rnk[i]] = i;
}
```
```cpp BZOJ 3676 [Apio2014]回文串
#include <cstdio>
#include <iostream>
#include <cstring>
#define ri register int
#define half(x) ((x) >> 1)
using namespace std;

typedef long long LL;
const int N = 3e5 + 5;

struct edge {
  int nxt, to;
} e[N << 1];
char s[N << 1], c[N];
int a[N << 1];
int fir[N << 1], size[N << 1];
int trans[N << 1][27], fa[N << 1], Max[N << 1], id[N], tot = 1, lst = 1;

inline void extend(int x, int I) {
  int p = lst, np = lst = ++ tot;
  id[I] = tot;
  size[np] = 1;
  Max[np] = Max[p] + 1;
  for (; p && !trans[p][x]; p = fa[p]) trans[p][x] = np;
  if (!p) fa[np] = 1;
  else {
    int q = trans[p][x];
    if (Max[q] == Max[p] + 1) fa[np] = q;
    else {
      int nq = ++ tot;
      memcpy(trans[nq], trans[q], sizeof trans[q]);
      fa[nq] = fa[q];
      fa[q] = fa[np] = nq;
      Max[nq] = Max[p] + 1;
      for (; trans[p][x] == q; p = fa[p]) trans[p][x] = nq;
    }
  }
}

inline void addedge(int x, int y) {
  static int cnt = 0;
  e[++ cnt] = (edge){ fir[x], y }; fir[x] = cnt;
}

int tmp; LL ans = 0;

inline void dfs(int x, int fa) {
  trans[x][0] = tmp = fa;
  for (ri i = 1; i < 20; i ++) trans[x][i] = tmp = trans[tmp][i - 1];
  for (int i = fir[x]; i; i = e[i].nxt)
    if (e[i].to != fa) dfs(e[i].to, x), size[x] += size[e[i].to];
}

inline void solve(int endpos, int len) {
  int x = id[endpos];
  for (ri i = 19; (~ i); i --)
    if (Max[trans[x][i]] >= len) x = trans[x][i];
  ans = max(ans, 1LL * len * size[x]);
}

int main() {
  scanf("%s", c + 1);
  int l = strlen(c + 1);
  for (int i = 1, j = 0; i <= l; i ++) {
    extend(c[i] - 'a', i);
    s[++ j] = 'z' + 1, s[++ j] = c[i];
  }
  for (int i = 2; i <= tot; i ++) addedge(fa[i], i);
  dfs(1, 0);
  s[l = l << 1 | 1] = 'z' + 1;
  int r = 0, pos = 0;
  for (int i = 1; i <= l; i ++) {
    if (i <= r) a[i] = min(a[pos * 2 - i], r - i);
    else {
      a[i] = 0;
      if (!(i & 1)) solve(i >> 1, 1);
    }
    if (a[i] + i < r) continue;
    while (i + a[i] + 1 <= l && i - a[i] - 1 > 0 && s[i + a[i] + 1] == s[i - a[i] - 1]) {
      a[i] ++;
      if (!((i + a[i]) & 1))
        solve(half(i + a[i]), half(i + a[i]) - half(i - a[i]) + 1);
    }
    pos = i; r = a[i] + i;
  }
  printf("%lld\n", ans);
  return 0;
}

```
```cpp BZOJ 3145 [Feyat Cup 1.5]Str
#include <cstdio>
#include <iostream>
#include <set>
#include <cstring>
#include <algorithm>
#define ri register int
using namespace std;

typedef set <int> Set;
const int N = 2e5 + 5;

struct edge {
  int nxt, to;
} e[N << 1];
char c[N];
int a[N << 1];
int l1, l2, pos[N];
Set A[N << 1], B[N << 1];
int tab[N][19], Log[N], ans = 0;
int rnk[N], id[N], buc1[N], buc2[N], _rnk[N], ord[N], hei[N];
int trans[N << 1][27], fa[N << 1], Max[N << 1], ID[N << 1], tot = 1, lst = 1;

inline void extend(int x, int I) {
  int p = lst, np = lst = ++ tot;
  pos[I] = np;
  Max[np] = Max[p] + 1;
  for (; !trans[p][x] && p; p = fa[p]) trans[p][x] = np;
  if (!p) fa[np] = 1;
  else {
    int q = trans[p][x];
    if (Max[p] + 1 == Max[q]) fa[np] = q;
    else {
      int nq = ++ tot;
      memcpy(trans[nq], trans[q], sizeof trans[q]);
      Max[nq] = Max[p] + 1;
      fa[nq] = fa[q];
      fa[np] = fa[q] = nq;
      for (; trans[p][x] == q; p = fa[p]) trans[p][x] = nq;
    }
  }
}

inline void GetRank(int n) {
  int g = max(n, 130);
  for (int i = 1; i <= n; i ++) rnk[i] = c[i];
  for (int h = 1; h <= n; h <<= 1) {
    memset(buc1, 0, sizeof(int) * (g + 2));
    memset(buc2, 0, sizeof(int) * (g + 2));
    int t = h >> 1;
    for (int i = 1; i <= n; i ++) {
      buc1[rnk[min(N - 1, i + t)]] ++;
      buc2[rnk[i]] ++;
    }
    for (int i = 1; i <= max(n, 130); i ++) {
      buc1[i] += buc1[i - 1];
      buc2[i] += buc2[i - 1];
    }
    for (int i = 1; i <= n; i ++) id[buc1[rnk[min(N - 1, i + t)]] --] = i;
    int pre = n;
    for (int i = n; i >= 1; i --) {
      if (i != n && rnk[min(N - 1, id[i] + t)] != rnk[min(N - 1, id[i + 1] + t)]) {
	for (int j = i + 1; j <= pre; j ++) buc2[rnk[id[j]]] --;
	pre = i;
      }
      _rnk[id[i]] = buc2[rnk[id[i]]];
    }
    swap(rnk, _rnk);
  }
  for (int i = 1; i <= n; i ++) ord[rnk[i]] = i;
  for (int i = 1, j, k = 0; i <= n; hei[rnk[i ++]] = k)
    for (k ? k -- : 0, j = ord[rnk[i] - 1]; c[i + k] == c[j + k]; k ++);
}

inline bool cmp(int a, int b) { return Max[a] > Max[b]; }

inline void ST(int n) {
  for (int i = 0; i <= 17; i ++) Log[1 << i] = i;
  for (int i = 1; i <= n; i ++) {
    if (!Log[i]) Log[i] = Log[i - 1];
    tab[i][0] = hei[i];
  }
  for (int h = 1, k = 1; h <= n; h <<= 1, k ++)
    for (int i = 1; i + h <= n; i ++) tab[i][k] = min(tab[i][k - 1], tab[i + h][k - 1]);
}

inline int LCP(int l, int r) {
  if (l == -1 || r == -1) return -1;
  if (l > r) swap(l, r); l ++;
  return min(tab[l][Log[r - l + 1]], tab[r - (1 << Log[r - l + 1]) + 1][Log[r - l + 1]]);
}

inline void Upd(const Set &s, const Set &b, int id) {
  if (b.size() == 0 || s.size() == 0) return;
  int res = 0, h;
  for (Set :: iterator it = s.begin(), d; it != s.end(); it ++) {
    h = (*it);
    if (h == -1) continue;
    d = b.lower_bound(h);
    if (d != b.end()) res = max(res, LCP(h, (*d)) + 1);
    if (d == b.begin()) continue;
    d --;
    res = max(res, LCP(h, (*d)) + 1);
  }
  ans = max(ans, res + Max[id]);
}

inline void Comb(Set &s, Set &e) {
  if (s.size() > e.size()) s.swap(e);
  for (Set :: iterator it = s.begin(); it != s.end(); it ++) e.insert(*it);
}

inline void Merge(int x, int f) {
  if (A[x].size() < B[f].size()) Upd(A[x], B[f], f);
  else Upd(B[f], A[x], f);
  if (A[f].size() < B[x].size()) Upd(A[f], B[x], f);
  else Upd(B[x], A[f], f);
  Comb(A[x], A[f]);
  Comb(B[x], B[f]);
}

int main() {
  scanf("%s", c + 1);
  l1 = strlen(c + 1);
  c[l1 + 1] = '%';
  scanf("%s", c + l1 + 2);
  l2 = strlen(c + l1 + 2);
  int n = l1 + l2 + 1, x;
  for (int i = 1; i <= n; i ++) extend(c[i] - 'a', i);
  GetRank(n); ST(n);
  
  for (int i = 1; i < l1; i ++)
    A[pos[i]].insert(rnk[i + 2]);
  A[pos[l1]].insert(-1);
  for (int i = l1 + 2; i < n; i ++)
    B[pos[i]].insert(rnk[i + 2]);
  B[pos[n - 1]].insert(-1);
  A[1].insert(rnk[2]);
  B[1].insert(rnk[l1 + 3]);
  Upd(A[1], B[1], 1);
  
  for (int i = 1; i <= tot; i ++) ID[i] = i;
  sort(ID + 1, ID + tot + 1, cmp);
  for (int i = 1; i <= tot; i ++) {
    x = ID[i];
    if (fa[x]) Merge(x, fa[x]);
  }
  ans = min(ans, l1);
  ans = min(ans, l2);
  printf("%d\n", ans);
  return 0;
}
```
