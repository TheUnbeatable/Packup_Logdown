## LOJ #2107 JLOI2015 城池攻占
### Description
n个城池构成了一个有根树的结构,有m个骑士从树上的一个城池出发向上攻克城池,如果骑士的生命大于城池的生命,那么可以攻克,否则骑士牺牲.攻克城池后骑士的生命会根据城池的属性加上或乘上一个值(保证乘上的值是正的),求每个城池牺牲的骑士数量以及每个骑士攻占的城池数量(n,m <= 3e5).
### Solution
一个骑士只会牺牲一次,考虑离线处理,每个骑士对应一个左偏树节点(小根堆),key为生命值,DFS将子节点的信息合并到父节点,然后不断将生命值最小的骑士弹出牺牲,知道根的key大于城池的生命值,然后打上标记( + , * ).由于乘上的树保证是正的,所以打标记后不会影响树中节点的大小关系,复杂度O(nlogn).
### [Code](https://loj.ac/submission/60856)
<!--more-->

## BZOJ2653 middle
### Description
给定一个长为n(n <= 20000)的序列,q个询问(q <= 25000),每次查询左端点在[a,b],右端点在[c,d]的连续序列中,中位数最大的序列的中位数.(强制在线)
### Idea
由于是求最大的那个,**所以应该从小的一侧向答案的逼近**.
我们二分答案x,如果记不小于x的数为1,小于x的数为-1,那么如果序列的和非负,**x就不大于中位数**,这样就可以从小向大逼近答案了.
**"不小于"保证了最后得到的答案是对应序列中的一个数**.
那么现在就是要求和最大的序列.[b+1,c-1]一定要选,只要求出[a,b]最大后缀和[c,d]最大前缀就可以了.按照权值排序后以位置为key建主席树,第i棵维护x等于第i小的数的时候的1,-1序列,这样第i-1棵到第i棵只要把一个数的值改成-1.复杂度O(Nlog^2N).
### [Code](https://cn.vjudge.net/solution/12656215)

## BZOJ1453 [Wc]Dface双面棋盘
### Description
对一个n * n的棋盘,每个格子颜色是黑或白,m次操作,每次把一个格子的颜色反转并查询黑/白联通块的数量.(n <= 200, m <= 10000).
### Idea
反转颜色的过程可以看作两个操作,删去原有颜色和加入新的颜色.如果没有删除操作只要用并查集就可以了,对于删除操作,我们可以用时间线段树,并查集按秩合并,转化成撤销操作.复杂度O(mlog^2(n^2)).
### [Code](https://cn.vjudge.net/solution/12660178)
